---
import { siteConfig } from "../config/site";
// In your Astro frontmatter
const { skills } = siteConfig.proficiencies;

function hexToHSL(hex: string) {
  let r = 0, g = 0, b = 0;

  if (hex.length === 4) {
    r = parseInt(hex[1] + hex[1], 16);
    g = parseInt(hex[2] + hex[2], 16);
    b = parseInt(hex[3] + hex[3], 16);
  } else {
    r = parseInt(hex.substring(1, 3), 16);
    g = parseInt(hex.substring(3, 5), 16);
    b = parseInt(hex.substring(5, 7), 16);
  }

  r /= 255;
  g /= 255;
  b /= 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0, s = 0;
  const l = (max + min) / 2;

  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return { h, s, l };
}

function pastelGradient(hex: string) {
  const { h, s, l } = hexToHSL(hex);

  return [
    `hsl(${h * 360}, ${Math.min(s * 100, 70)}%, ${Math.min(l * 100 + 20, 85)}%)`,
    `hsl(${h * 360}, ${Math.min(s * 100, 60)}%, ${Math.min(l * 100 + 10, 75)}%)`,
    `hsl(${h * 360}, ${Math.min(s * 100, 50)}%, ${Math.min(l * 100, 65)}%)`,
  ];
}
---

<section class="proficiency-section" id="proficiency-section">
  <div class="proficiency-content">
    <h2 class="proficiency-title">{siteConfig.proficiencies.title}</h2>
    <div class="skills-grid">
      {
        siteConfig.proficiencies.skills.map((skill) => {
          const gradient = pastelGradient(skill.themeColor);

          return (
          <Fragment>
            <div class="skill-card" data-percentage={skill.percentage}>
              <div class="skill-name" style={"color: " + skill.themeColor}>
                {skill.name}
              </div>
              <div class="circular-progress-container">
                <div class="circular-progress">
                  <div
                    class="circular-progress-text"
                    style={"color:" + skill.themeColor}
                  >
                    <span
                      class="skill-percentage"
                      data-target={skill.percentage}
                    >
                      0
                    </span>
                    %
                  </div>
                  <svg class="progress-ring" width="180" height="180">
                    <circle
                      class="progress-ring-circle-bg"
                      stroke="#ffffff"
                      stroke-width="10"
                      fill="transparent"
                      r="80"
                      cx="90"
                      cy="90"
                    />
                    <circle
                      class="progress-ring-circle"
                      stroke={"url(#gradient-" + skill.index + ")"}
                      stroke-width="10"
                      fill="transparent"
                      r="80"
                      cx="90"
                      cy="90"
                      stroke-dasharray="502.65"
                      stroke-dashoffset="502.65"
                      data-circumference="502.65"
                    />
                    <defs>
                      <linearGradient
  id={"gradient-" + skill.index}
  gradientUnits="objectBoundingBox"
  x1="0%"
  y1="0%"
  x2="100%"
  y2="100%"
>
  <stop offset="0%" stop-color={gradient[0]} />
  <stop offset="70%" stop-color={gradient[1]} />
  <stop offset="100%" stop-color={gradient[2]} />
</linearGradient>
                    </defs>
                  </svg>
                </div>
              </div>
            </div>
          </Fragment>
        )})
      }
    </div>
  </div>
</section>

<script>
  function hexToHSL(hex: string) {
    let r = 0,
      g = 0,
      b = 0;

    if (hex.length === 4) {
      r = parseInt(hex[1] + hex[1], 16);
      g = parseInt(hex[2] + hex[2], 16);
      b = parseInt(hex[3] + hex[3], 16);
    } else {
      r = parseInt(hex.substring(1, 3), 16);
      g = parseInt(hex.substring(3, 5), 16);
      b = parseInt(hex.substring(5, 7), 16);
    }

    r /= 255;
    g /= 255;
    b /= 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0,
      s = 0;
    const l = (max + min) / 2;

    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }

    return { h, s, l };
  }

  function pastelGradient(hex: string) {
    const { h, s, l } = hexToHSL(hex);

    return [
      `hsl(${h * 360}, ${Math.min(s * 100, 70)}%, ${Math.min(l * 100 + 20, 85)}%)`,
      `hsl(${h * 360}, ${Math.min(s * 100, 60)}%, ${Math.min(l * 100 + 10, 75)}%)`,
      `hsl(${h * 360}, ${Math.min(s * 100, 50)}%, ${Math.min(l * 100, 65)}%)`,
    ];
  }

  // Number animation: count from 0 to target
  function animateNumber(
    element: HTMLElement,
    target: number,
    duration = 2000,
  ) {
    const start = 0;
    const startTime = performance.now();

    function update(currentTime: number) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);

      // Ease-out function
      const easeOutQuart = 1 - Math.pow(1 - progress, 4);
      const current = Math.floor(start + (target - start) * easeOutQuart);

      element.textContent = current.toString();

      if (progress < 1) {
        requestAnimationFrame(update);
      } else {
        element.textContent = target.toString();
      }
    }

    requestAnimationFrame(update);
  }

  // Circular progress animation
  function animateCircularProgress(
    circle: SVGCircleElement,
    percentage: number,
    duration = 2000,
  ) {
    const circumference = parseFloat(
      circle.getAttribute("data-circumference") || "502.65",
    );
    const startTime = performance.now();
    const offset = circumference;

    function update(currentTime: number) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);

      // Ease-out function
      const easeOutQuart = 1 - Math.pow(1 - progress, 4);
      const currentPercentage = percentage * easeOutQuart;
      const currentOffset =
        circumference - (currentPercentage / 100) * circumference;

      circle.style.strokeDashoffset = currentOffset.toString();

      if (progress < 1) {
        requestAnimationFrame(update);
      } else {
        circle.style.strokeDashoffset = (
          circumference -
          (percentage / 100) * circumference
        ).toString();
      }
    }

    requestAnimationFrame(update);
  }

  // Use Intersection Observer to trigger on scroll
  const proficiencySection = document.getElementById("proficiency-section");
  let hasAnimated = false;

  if (proficiencySection) {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && !hasAnimated) {
            hasAnimated = true;

            // Get all skill cards
            const skillCards =
              proficiencySection.querySelectorAll(".skill-card");

            skillCards.forEach((card, index) => {
              setTimeout(() => {
                const percentageElement = card.querySelector(
                  ".skill-percentage",
                ) as HTMLElement;
                const progressCircle = card.querySelector(
                  ".progress-ring-circle",
                ) as SVGCircleElement;
                const percentage = parseInt(
                  card.getAttribute("data-percentage") || "0",
                );

                if (percentageElement && progressCircle) {
                  // Start number animation
                  animateNumber(percentageElement, percentage);

                  // Start circular progress animation
                  animateCircularProgress(progressCircle, percentage);
                }
              }, index * 150); // Stagger each skill by 150ms
            });
          }
        });
      },
      {
        threshold: 0.3, // Trigger when 30% is visible
      },
    );

    observer.observe(proficiencySection);
  }
</script>
